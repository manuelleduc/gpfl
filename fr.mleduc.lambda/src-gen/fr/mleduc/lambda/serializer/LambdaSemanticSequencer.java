/*
 * generated by Xtext 2.12.0
 */
package fr.mleduc.lambda.serializer;

import com.google.inject.Inject;
import fr.mleduc.gpfl.gpfl.AcceptCmd;
import fr.mleduc.gpfl.gpfl.AlarmCmd;
import fr.mleduc.gpfl.gpfl.AutomataDef;
import fr.mleduc.gpfl.gpfl.AutomatonCmd;
import fr.mleduc.gpfl.gpfl.CmdAdd;
import fr.mleduc.gpfl.gpfl.CmdAnd;
import fr.mleduc.gpfl.gpfl.CmdEq;
import fr.mleduc.gpfl.gpfl.CmdGCompare;
import fr.mleduc.gpfl.gpfl.CmdGECompare;
import fr.mleduc.gpfl.gpfl.CmdLCompare;
import fr.mleduc.gpfl.gpfl.CmdLECompare;
import fr.mleduc.gpfl.gpfl.CmdNEq;
import fr.mleduc.gpfl.gpfl.CmdSub;
import fr.mleduc.gpfl.gpfl.CondStmt;
import fr.mleduc.gpfl.gpfl.DropCmd;
import fr.mleduc.gpfl.gpfl.Field;
import fr.mleduc.gpfl.gpfl.GBoolFalse;
import fr.mleduc.gpfl.gpfl.GBoolTrue;
import fr.mleduc.gpfl.gpfl.GExpression;
import fr.mleduc.gpfl.gpfl.GpflPackage;
import fr.mleduc.gpfl.gpfl.InPort;
import fr.mleduc.gpfl.gpfl.IntLitCmd;
import fr.mleduc.gpfl.gpfl.InterruptStmt;
import fr.mleduc.gpfl.gpfl.IterStmt;
import fr.mleduc.gpfl.gpfl.NopCmd;
import fr.mleduc.gpfl.gpfl.OutPort;
import fr.mleduc.gpfl.gpfl.PortLit;
import fr.mleduc.gpfl.gpfl.Program;
import fr.mleduc.gpfl.gpfl.SendCmd;
import fr.mleduc.gpfl.gpfl.SetCmd;
import fr.mleduc.gpfl.gpfl.State;
import fr.mleduc.gpfl.gpfl.StpCmd;
import fr.mleduc.gpfl.gpfl.StringLit;
import fr.mleduc.gpfl.gpfl.Transition;
import fr.mleduc.gpfl.gpfl.Variable;
import fr.mleduc.gpfl.serializer.GpflSemanticSequencer;
import fr.mleduc.lambda.lambda.LambdaPackage;
import fr.mleduc.lambda.lambda.MethodCall;
import fr.mleduc.lambda.lambda.MethodDef;
import fr.mleduc.lambda.services.LambdaGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class LambdaSemanticSequencer extends GpflSemanticSequencer {

	@Inject
	private LambdaGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GpflPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GpflPackage.ACCEPT_CMD:
				sequence_Cmd(context, (AcceptCmd) semanticObject); 
				return; 
			case GpflPackage.ALARM_CMD:
				sequence_Cmd(context, (AlarmCmd) semanticObject); 
				return; 
			case GpflPackage.AUTOMATA_DEF:
				sequence_AutomataDef(context, (AutomataDef) semanticObject); 
				return; 
			case GpflPackage.AUTOMATON_CMD:
				sequence_Cmd(context, (AutomatonCmd) semanticObject); 
				return; 
			case GpflPackage.CMD_ADD:
				sequence_CmdAdd(context, (CmdAdd) semanticObject); 
				return; 
			case GpflPackage.CMD_AND:
				sequence_CmdAnd_CmdOr(context, (CmdAnd) semanticObject); 
				return; 
			case GpflPackage.CMD_EQ:
				sequence_CmdEq(context, (CmdEq) semanticObject); 
				return; 
			case GpflPackage.CMD_GCOMPARE:
				sequence_CmdGCompare(context, (CmdGCompare) semanticObject); 
				return; 
			case GpflPackage.CMD_GE_COMPARE:
				sequence_CmdGECompare(context, (CmdGECompare) semanticObject); 
				return; 
			case GpflPackage.CMD_LCOMPARE:
				sequence_CmdLCompare(context, (CmdLCompare) semanticObject); 
				return; 
			case GpflPackage.CMD_LE_COMPARE:
				sequence_CmdLECompare(context, (CmdLECompare) semanticObject); 
				return; 
			case GpflPackage.CMD_NEQ:
				sequence_CmdNeq(context, (CmdNEq) semanticObject); 
				return; 
			case GpflPackage.CMD_SUB:
				sequence_CmdSub(context, (CmdSub) semanticObject); 
				return; 
			case GpflPackage.COND_STMT:
				sequence_GExpression(context, (CondStmt) semanticObject); 
				return; 
			case GpflPackage.DROP_CMD:
				sequence_Cmd(context, (DropCmd) semanticObject); 
				return; 
			case GpflPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case GpflPackage.GBOOL_FALSE:
				sequence_CmdLit(context, (GBoolFalse) semanticObject); 
				return; 
			case GpflPackage.GBOOL_TRUE:
				sequence_CmdLit(context, (GBoolTrue) semanticObject); 
				return; 
			case GpflPackage.GEXPRESSION:
				sequence_CmdNot(context, (GExpression) semanticObject); 
				return; 
			case GpflPackage.IN_PORT:
				sequence_Port(context, (InPort) semanticObject); 
				return; 
			case GpflPackage.INT_LIT_CMD:
				sequence_CmdLit(context, (IntLitCmd) semanticObject); 
				return; 
			case GpflPackage.INTERRUPT_STMT:
				sequence_GExpression(context, (InterruptStmt) semanticObject); 
				return; 
			case GpflPackage.ITER_STMT:
				sequence_GExpression(context, (IterStmt) semanticObject); 
				return; 
			case GpflPackage.NOP_CMD:
				sequence_Cmd(context, (NopCmd) semanticObject); 
				return; 
			case GpflPackage.OUT_PORT:
				sequence_Port(context, (OutPort) semanticObject); 
				return; 
			case GpflPackage.PORT_LIT:
				sequence_CmdLit(context, (PortLit) semanticObject); 
				return; 
			case GpflPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case GpflPackage.SEND_CMD:
				sequence_Cmd(context, (SendCmd) semanticObject); 
				return; 
			case GpflPackage.SET_CMD:
				sequence_Cmd(context, (SetCmd) semanticObject); 
				return; 
			case GpflPackage.STATE:
				sequence_State(context, (State) semanticObject); 
				return; 
			case GpflPackage.STP_CMD:
				sequence_Cmd(context, (StpCmd) semanticObject); 
				return; 
			case GpflPackage.STRING_LIT:
				sequence_CmdLit(context, (StringLit) semanticObject); 
				return; 
			case GpflPackage.TRANSITION:
				sequence_Transition(context, (Transition) semanticObject); 
				return; 
			case GpflPackage.VARIABLE:
				sequence_CmdLit(context, (Variable) semanticObject); 
				return; 
			}
		else if (epackage == LambdaPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case LambdaPackage.METHOD_CALL:
				sequence_GExpression(context, (MethodCall) semanticObject); 
				return; 
			case LambdaPackage.METHOD_DEF:
				sequence_GExpression(context, (MethodDef) semanticObject); 
				return; 
			case LambdaPackage.PARAMETER:
				sequence_Parameter(context, (fr.mleduc.lambda.lambda.Parameter) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     GExpression returns MethodCall
	 *
	 * Constraint:
	 *     (method=[MethodDef|ID] (params+=GExpression params+=GExpression*)?)
	 */
	protected void sequence_GExpression(ISerializationContext context, MethodCall semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns MethodDef
	 *
	 * Constraint:
	 *     (name=ID (params+=Parameter params+=Parameter*)? stmts+=GExpression*)
	 */
	protected void sequence_GExpression(ISerializationContext context, MethodDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Parameter returns Parameter
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Parameter(ISerializationContext context, fr.mleduc.lambda.lambda.Parameter semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, LambdaPackage.Literals.PARAMETER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, LambdaPackage.Literals.PARAMETER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
}
