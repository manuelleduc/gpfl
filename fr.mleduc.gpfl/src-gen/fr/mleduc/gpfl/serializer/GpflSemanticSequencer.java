/*
 * generated by Xtext 2.12.0
 */
package fr.mleduc.gpfl.serializer;

import com.google.inject.Inject;
import fr.mleduc.gpfl.gpfl.AcceptCmd;
import fr.mleduc.gpfl.gpfl.AlarmCmd;
import fr.mleduc.gpfl.gpfl.AutomataDef;
import fr.mleduc.gpfl.gpfl.AutomatonCmd;
import fr.mleduc.gpfl.gpfl.CmdAdd;
import fr.mleduc.gpfl.gpfl.CmdAnd;
import fr.mleduc.gpfl.gpfl.CmdEq;
import fr.mleduc.gpfl.gpfl.CmdGCompare;
import fr.mleduc.gpfl.gpfl.CmdGECompare;
import fr.mleduc.gpfl.gpfl.CmdLCompare;
import fr.mleduc.gpfl.gpfl.CmdLECompare;
import fr.mleduc.gpfl.gpfl.CmdNEq;
import fr.mleduc.gpfl.gpfl.CmdSub;
import fr.mleduc.gpfl.gpfl.CondStmt;
import fr.mleduc.gpfl.gpfl.DropCmd;
import fr.mleduc.gpfl.gpfl.Field;
import fr.mleduc.gpfl.gpfl.GBoolFalse;
import fr.mleduc.gpfl.gpfl.GBoolTrue;
import fr.mleduc.gpfl.gpfl.GExpression;
import fr.mleduc.gpfl.gpfl.GpflPackage;
import fr.mleduc.gpfl.gpfl.InPort;
import fr.mleduc.gpfl.gpfl.IntLitCmd;
import fr.mleduc.gpfl.gpfl.InterruptStmt;
import fr.mleduc.gpfl.gpfl.IterStmt;
import fr.mleduc.gpfl.gpfl.NopCmd;
import fr.mleduc.gpfl.gpfl.OutPort;
import fr.mleduc.gpfl.gpfl.PortLit;
import fr.mleduc.gpfl.gpfl.Program;
import fr.mleduc.gpfl.gpfl.SendCmd;
import fr.mleduc.gpfl.gpfl.SetCmd;
import fr.mleduc.gpfl.gpfl.State;
import fr.mleduc.gpfl.gpfl.StpCmd;
import fr.mleduc.gpfl.gpfl.StringLit;
import fr.mleduc.gpfl.gpfl.Transition;
import fr.mleduc.gpfl.gpfl.Variable;
import fr.mleduc.gpfl.services.GpflGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class GpflSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private GpflGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == GpflPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case GpflPackage.ACCEPT_CMD:
				sequence_Cmd(context, (AcceptCmd) semanticObject); 
				return; 
			case GpflPackage.ALARM_CMD:
				sequence_Cmd(context, (AlarmCmd) semanticObject); 
				return; 
			case GpflPackage.AUTOMATA_DEF:
				sequence_AutomataDef(context, (AutomataDef) semanticObject); 
				return; 
			case GpflPackage.AUTOMATON_CMD:
				sequence_Cmd(context, (AutomatonCmd) semanticObject); 
				return; 
			case GpflPackage.CMD_ADD:
				sequence_CmdAdd(context, (CmdAdd) semanticObject); 
				return; 
			case GpflPackage.CMD_AND:
				sequence_CmdAnd_CmdOr(context, (CmdAnd) semanticObject); 
				return; 
			case GpflPackage.CMD_EQ:
				sequence_CmdEq(context, (CmdEq) semanticObject); 
				return; 
			case GpflPackage.CMD_GCOMPARE:
				sequence_CmdGCompare(context, (CmdGCompare) semanticObject); 
				return; 
			case GpflPackage.CMD_GE_COMPARE:
				sequence_CmdGECompare(context, (CmdGECompare) semanticObject); 
				return; 
			case GpflPackage.CMD_LCOMPARE:
				sequence_CmdLCompare(context, (CmdLCompare) semanticObject); 
				return; 
			case GpflPackage.CMD_LE_COMPARE:
				sequence_CmdLECompare(context, (CmdLECompare) semanticObject); 
				return; 
			case GpflPackage.CMD_NEQ:
				sequence_CmdNeq(context, (CmdNEq) semanticObject); 
				return; 
			case GpflPackage.CMD_SUB:
				sequence_CmdSub(context, (CmdSub) semanticObject); 
				return; 
			case GpflPackage.COND_STMT:
				sequence_GExpression(context, (CondStmt) semanticObject); 
				return; 
			case GpflPackage.DROP_CMD:
				sequence_Cmd(context, (DropCmd) semanticObject); 
				return; 
			case GpflPackage.FIELD:
				sequence_Field(context, (Field) semanticObject); 
				return; 
			case GpflPackage.GBOOL_FALSE:
				sequence_CmdLit(context, (GBoolFalse) semanticObject); 
				return; 
			case GpflPackage.GBOOL_TRUE:
				sequence_CmdLit(context, (GBoolTrue) semanticObject); 
				return; 
			case GpflPackage.GEXPRESSION:
				sequence_CmdNot(context, (GExpression) semanticObject); 
				return; 
			case GpflPackage.IN_PORT:
				sequence_Port(context, (InPort) semanticObject); 
				return; 
			case GpflPackage.INT_LIT_CMD:
				sequence_CmdLit(context, (IntLitCmd) semanticObject); 
				return; 
			case GpflPackage.INTERRUPT_STMT:
				sequence_GExpression(context, (InterruptStmt) semanticObject); 
				return; 
			case GpflPackage.ITER_STMT:
				sequence_GExpression(context, (IterStmt) semanticObject); 
				return; 
			case GpflPackage.NOP_CMD:
				sequence_Cmd(context, (NopCmd) semanticObject); 
				return; 
			case GpflPackage.OUT_PORT:
				sequence_Port(context, (OutPort) semanticObject); 
				return; 
			case GpflPackage.PORT_LIT:
				sequence_CmdLit(context, (PortLit) semanticObject); 
				return; 
			case GpflPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case GpflPackage.SEND_CMD:
				sequence_Cmd(context, (SendCmd) semanticObject); 
				return; 
			case GpflPackage.SET_CMD:
				sequence_Cmd(context, (SetCmd) semanticObject); 
				return; 
			case GpflPackage.STATE:
				sequence_State(context, (State) semanticObject); 
				return; 
			case GpflPackage.STP_CMD:
				sequence_Cmd(context, (StpCmd) semanticObject); 
				return; 
			case GpflPackage.STRING_LIT:
				sequence_CmdLit(context, (StringLit) semanticObject); 
				return; 
			case GpflPackage.TRANSITION:
				sequence_Transition(context, (Transition) semanticObject); 
				return; 
			case GpflPackage.VARIABLE:
				sequence_CmdLit(context, (Variable) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AutomataDef returns AutomataDef
	 *
	 * Constraint:
	 *     (name=ID init=[State|ID] states+=State*)
	 */
	protected void sequence_AutomataDef(ISerializationContext context, AutomataDef semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns CmdAdd
	 *     Cmd returns CmdAdd
	 *     CmdExpr returns CmdAdd
	 *     CmdOr returns CmdAdd
	 *     CmdOr.CmdAnd_1_0_0_0 returns CmdAdd
	 *     CmdAnd returns CmdAdd
	 *     CmdAnd.CmdAnd_1_0_0_0 returns CmdAdd
	 *     CmdEq returns CmdAdd
	 *     CmdEq.CmdEq_1_0_0_0 returns CmdAdd
	 *     CmdNeq returns CmdAdd
	 *     CmdNeq.CmdNEq_1_0_0_0 returns CmdAdd
	 *     CmdGECompare returns CmdAdd
	 *     CmdGECompare.CmdGECompare_1_0_0_0 returns CmdAdd
	 *     CmdLECompare returns CmdAdd
	 *     CmdLECompare.CmdLECompare_1_0_0_0 returns CmdAdd
	 *     CmdGCompare returns CmdAdd
	 *     CmdGCompare.CmdGCompare_1_0_0_0 returns CmdAdd
	 *     CmdLCompare returns CmdAdd
	 *     CmdLCompare.CmdLCompare_1_0_0_0 returns CmdAdd
	 *     CmdAdd returns CmdAdd
	 *     CmdAdd.CmdAdd_1_0_0_0 returns CmdAdd
	 *     CmdSub returns CmdAdd
	 *     CmdSub.CmdSub_1_0_0_0 returns CmdAdd
	 *     CmdNot returns CmdAdd
	 *     CmdLit returns CmdAdd
	 *
	 * Constraint:
	 *     (left=CmdAdd_CmdAdd_1_0_0_0 right=CmdSub)
	 */
	protected void sequence_CmdAdd(ISerializationContext context, CmdAdd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.CMD_ADD__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.CMD_ADD__LEFT));
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.CMD_ADD__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.CMD_ADD__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCmdAddAccess().getCmdAddLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCmdAddAccess().getRightCmdSubParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns CmdAnd
	 *     Cmd returns CmdAnd
	 *     CmdExpr returns CmdAnd
	 *     CmdOr returns CmdAnd
	 *     CmdOr.CmdAnd_1_0_0_0 returns CmdAnd
	 *     CmdAnd returns CmdAnd
	 *     CmdAnd.CmdAnd_1_0_0_0 returns CmdAnd
	 *     CmdEq returns CmdAnd
	 *     CmdEq.CmdEq_1_0_0_0 returns CmdAnd
	 *     CmdNeq returns CmdAnd
	 *     CmdNeq.CmdNEq_1_0_0_0 returns CmdAnd
	 *     CmdGECompare returns CmdAnd
	 *     CmdGECompare.CmdGECompare_1_0_0_0 returns CmdAnd
	 *     CmdLECompare returns CmdAnd
	 *     CmdLECompare.CmdLECompare_1_0_0_0 returns CmdAnd
	 *     CmdGCompare returns CmdAnd
	 *     CmdGCompare.CmdGCompare_1_0_0_0 returns CmdAnd
	 *     CmdLCompare returns CmdAnd
	 *     CmdLCompare.CmdLCompare_1_0_0_0 returns CmdAnd
	 *     CmdAdd returns CmdAnd
	 *     CmdAdd.CmdAdd_1_0_0_0 returns CmdAnd
	 *     CmdSub returns CmdAnd
	 *     CmdSub.CmdSub_1_0_0_0 returns CmdAnd
	 *     CmdNot returns CmdAnd
	 *     CmdLit returns CmdAnd
	 *
	 * Constraint:
	 *     ((left=CmdOr_CmdAnd_1_0_0_0 right=CmdAnd) | (left=CmdAnd_CmdAnd_1_0_0_0 right=CmdEq))
	 */
	protected void sequence_CmdAnd_CmdOr(ISerializationContext context, CmdAnd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns CmdEq
	 *     Cmd returns CmdEq
	 *     CmdExpr returns CmdEq
	 *     CmdOr returns CmdEq
	 *     CmdOr.CmdAnd_1_0_0_0 returns CmdEq
	 *     CmdAnd returns CmdEq
	 *     CmdAnd.CmdAnd_1_0_0_0 returns CmdEq
	 *     CmdEq returns CmdEq
	 *     CmdEq.CmdEq_1_0_0_0 returns CmdEq
	 *     CmdNeq returns CmdEq
	 *     CmdNeq.CmdNEq_1_0_0_0 returns CmdEq
	 *     CmdGECompare returns CmdEq
	 *     CmdGECompare.CmdGECompare_1_0_0_0 returns CmdEq
	 *     CmdLECompare returns CmdEq
	 *     CmdLECompare.CmdLECompare_1_0_0_0 returns CmdEq
	 *     CmdGCompare returns CmdEq
	 *     CmdGCompare.CmdGCompare_1_0_0_0 returns CmdEq
	 *     CmdLCompare returns CmdEq
	 *     CmdLCompare.CmdLCompare_1_0_0_0 returns CmdEq
	 *     CmdAdd returns CmdEq
	 *     CmdAdd.CmdAdd_1_0_0_0 returns CmdEq
	 *     CmdSub returns CmdEq
	 *     CmdSub.CmdSub_1_0_0_0 returns CmdEq
	 *     CmdNot returns CmdEq
	 *     CmdLit returns CmdEq
	 *
	 * Constraint:
	 *     (left=CmdEq_CmdEq_1_0_0_0 right=CmdNeq)
	 */
	protected void sequence_CmdEq(ISerializationContext context, CmdEq semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.CMD_EQ__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.CMD_EQ__LEFT));
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.CMD_EQ__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.CMD_EQ__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCmdEqAccess().getCmdEqLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCmdEqAccess().getRightCmdNeqParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns CmdGCompare
	 *     Cmd returns CmdGCompare
	 *     CmdExpr returns CmdGCompare
	 *     CmdOr returns CmdGCompare
	 *     CmdOr.CmdAnd_1_0_0_0 returns CmdGCompare
	 *     CmdAnd returns CmdGCompare
	 *     CmdAnd.CmdAnd_1_0_0_0 returns CmdGCompare
	 *     CmdEq returns CmdGCompare
	 *     CmdEq.CmdEq_1_0_0_0 returns CmdGCompare
	 *     CmdNeq returns CmdGCompare
	 *     CmdNeq.CmdNEq_1_0_0_0 returns CmdGCompare
	 *     CmdGECompare returns CmdGCompare
	 *     CmdGECompare.CmdGECompare_1_0_0_0 returns CmdGCompare
	 *     CmdLECompare returns CmdGCompare
	 *     CmdLECompare.CmdLECompare_1_0_0_0 returns CmdGCompare
	 *     CmdGCompare returns CmdGCompare
	 *     CmdGCompare.CmdGCompare_1_0_0_0 returns CmdGCompare
	 *     CmdLCompare returns CmdGCompare
	 *     CmdLCompare.CmdLCompare_1_0_0_0 returns CmdGCompare
	 *     CmdAdd returns CmdGCompare
	 *     CmdAdd.CmdAdd_1_0_0_0 returns CmdGCompare
	 *     CmdSub returns CmdGCompare
	 *     CmdSub.CmdSub_1_0_0_0 returns CmdGCompare
	 *     CmdNot returns CmdGCompare
	 *     CmdLit returns CmdGCompare
	 *
	 * Constraint:
	 *     (left=CmdGCompare_CmdGCompare_1_0_0_0 right=CmdLCompare)
	 */
	protected void sequence_CmdGCompare(ISerializationContext context, CmdGCompare semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.CMD_GCOMPARE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.CMD_GCOMPARE__LEFT));
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.CMD_GCOMPARE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.CMD_GCOMPARE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCmdGCompareAccess().getCmdGCompareLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCmdGCompareAccess().getRightCmdLCompareParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns CmdGECompare
	 *     Cmd returns CmdGECompare
	 *     CmdExpr returns CmdGECompare
	 *     CmdOr returns CmdGECompare
	 *     CmdOr.CmdAnd_1_0_0_0 returns CmdGECompare
	 *     CmdAnd returns CmdGECompare
	 *     CmdAnd.CmdAnd_1_0_0_0 returns CmdGECompare
	 *     CmdEq returns CmdGECompare
	 *     CmdEq.CmdEq_1_0_0_0 returns CmdGECompare
	 *     CmdNeq returns CmdGECompare
	 *     CmdNeq.CmdNEq_1_0_0_0 returns CmdGECompare
	 *     CmdGECompare returns CmdGECompare
	 *     CmdGECompare.CmdGECompare_1_0_0_0 returns CmdGECompare
	 *     CmdLECompare returns CmdGECompare
	 *     CmdLECompare.CmdLECompare_1_0_0_0 returns CmdGECompare
	 *     CmdGCompare returns CmdGECompare
	 *     CmdGCompare.CmdGCompare_1_0_0_0 returns CmdGECompare
	 *     CmdLCompare returns CmdGECompare
	 *     CmdLCompare.CmdLCompare_1_0_0_0 returns CmdGECompare
	 *     CmdAdd returns CmdGECompare
	 *     CmdAdd.CmdAdd_1_0_0_0 returns CmdGECompare
	 *     CmdSub returns CmdGECompare
	 *     CmdSub.CmdSub_1_0_0_0 returns CmdGECompare
	 *     CmdNot returns CmdGECompare
	 *     CmdLit returns CmdGECompare
	 *
	 * Constraint:
	 *     (left=CmdGECompare_CmdGECompare_1_0_0_0 right=CmdLECompare)
	 */
	protected void sequence_CmdGECompare(ISerializationContext context, CmdGECompare semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.CMD_GE_COMPARE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.CMD_GE_COMPARE__LEFT));
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.CMD_GE_COMPARE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.CMD_GE_COMPARE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCmdGECompareAccess().getCmdGECompareLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCmdGECompareAccess().getRightCmdLECompareParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns CmdLCompare
	 *     Cmd returns CmdLCompare
	 *     CmdExpr returns CmdLCompare
	 *     CmdOr returns CmdLCompare
	 *     CmdOr.CmdAnd_1_0_0_0 returns CmdLCompare
	 *     CmdAnd returns CmdLCompare
	 *     CmdAnd.CmdAnd_1_0_0_0 returns CmdLCompare
	 *     CmdEq returns CmdLCompare
	 *     CmdEq.CmdEq_1_0_0_0 returns CmdLCompare
	 *     CmdNeq returns CmdLCompare
	 *     CmdNeq.CmdNEq_1_0_0_0 returns CmdLCompare
	 *     CmdGECompare returns CmdLCompare
	 *     CmdGECompare.CmdGECompare_1_0_0_0 returns CmdLCompare
	 *     CmdLECompare returns CmdLCompare
	 *     CmdLECompare.CmdLECompare_1_0_0_0 returns CmdLCompare
	 *     CmdGCompare returns CmdLCompare
	 *     CmdGCompare.CmdGCompare_1_0_0_0 returns CmdLCompare
	 *     CmdLCompare returns CmdLCompare
	 *     CmdLCompare.CmdLCompare_1_0_0_0 returns CmdLCompare
	 *     CmdAdd returns CmdLCompare
	 *     CmdAdd.CmdAdd_1_0_0_0 returns CmdLCompare
	 *     CmdSub returns CmdLCompare
	 *     CmdSub.CmdSub_1_0_0_0 returns CmdLCompare
	 *     CmdNot returns CmdLCompare
	 *     CmdLit returns CmdLCompare
	 *
	 * Constraint:
	 *     (left=CmdLCompare_CmdLCompare_1_0_0_0 right=CmdAdd)
	 */
	protected void sequence_CmdLCompare(ISerializationContext context, CmdLCompare semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.CMD_LCOMPARE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.CMD_LCOMPARE__LEFT));
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.CMD_LCOMPARE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.CMD_LCOMPARE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCmdLCompareAccess().getCmdLCompareLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCmdLCompareAccess().getRightCmdAddParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns CmdLECompare
	 *     Cmd returns CmdLECompare
	 *     CmdExpr returns CmdLECompare
	 *     CmdOr returns CmdLECompare
	 *     CmdOr.CmdAnd_1_0_0_0 returns CmdLECompare
	 *     CmdAnd returns CmdLECompare
	 *     CmdAnd.CmdAnd_1_0_0_0 returns CmdLECompare
	 *     CmdEq returns CmdLECompare
	 *     CmdEq.CmdEq_1_0_0_0 returns CmdLECompare
	 *     CmdNeq returns CmdLECompare
	 *     CmdNeq.CmdNEq_1_0_0_0 returns CmdLECompare
	 *     CmdGECompare returns CmdLECompare
	 *     CmdGECompare.CmdGECompare_1_0_0_0 returns CmdLECompare
	 *     CmdLECompare returns CmdLECompare
	 *     CmdLECompare.CmdLECompare_1_0_0_0 returns CmdLECompare
	 *     CmdGCompare returns CmdLECompare
	 *     CmdGCompare.CmdGCompare_1_0_0_0 returns CmdLECompare
	 *     CmdLCompare returns CmdLECompare
	 *     CmdLCompare.CmdLCompare_1_0_0_0 returns CmdLECompare
	 *     CmdAdd returns CmdLECompare
	 *     CmdAdd.CmdAdd_1_0_0_0 returns CmdLECompare
	 *     CmdSub returns CmdLECompare
	 *     CmdSub.CmdSub_1_0_0_0 returns CmdLECompare
	 *     CmdNot returns CmdLECompare
	 *     CmdLit returns CmdLECompare
	 *
	 * Constraint:
	 *     (left=CmdLECompare_CmdLECompare_1_0_0_0 right=CmdGCompare)
	 */
	protected void sequence_CmdLECompare(ISerializationContext context, CmdLECompare semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.CMD_LE_COMPARE__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.CMD_LE_COMPARE__LEFT));
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.CMD_LE_COMPARE__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.CMD_LE_COMPARE__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCmdLECompareAccess().getCmdLECompareLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCmdLECompareAccess().getRightCmdGCompareParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns GBoolFalse
	 *     Cmd returns GBoolFalse
	 *     CmdExpr returns GBoolFalse
	 *     CmdOr returns GBoolFalse
	 *     CmdOr.CmdAnd_1_0_0_0 returns GBoolFalse
	 *     CmdAnd returns GBoolFalse
	 *     CmdAnd.CmdAnd_1_0_0_0 returns GBoolFalse
	 *     CmdEq returns GBoolFalse
	 *     CmdEq.CmdEq_1_0_0_0 returns GBoolFalse
	 *     CmdNeq returns GBoolFalse
	 *     CmdNeq.CmdNEq_1_0_0_0 returns GBoolFalse
	 *     CmdGECompare returns GBoolFalse
	 *     CmdGECompare.CmdGECompare_1_0_0_0 returns GBoolFalse
	 *     CmdLECompare returns GBoolFalse
	 *     CmdLECompare.CmdLECompare_1_0_0_0 returns GBoolFalse
	 *     CmdGCompare returns GBoolFalse
	 *     CmdGCompare.CmdGCompare_1_0_0_0 returns GBoolFalse
	 *     CmdLCompare returns GBoolFalse
	 *     CmdLCompare.CmdLCompare_1_0_0_0 returns GBoolFalse
	 *     CmdAdd returns GBoolFalse
	 *     CmdAdd.CmdAdd_1_0_0_0 returns GBoolFalse
	 *     CmdSub returns GBoolFalse
	 *     CmdSub.CmdSub_1_0_0_0 returns GBoolFalse
	 *     CmdNot returns GBoolFalse
	 *     CmdLit returns GBoolFalse
	 *
	 * Constraint:
	 *     {GBoolFalse}
	 */
	protected void sequence_CmdLit(ISerializationContext context, GBoolFalse semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns GBoolTrue
	 *     Cmd returns GBoolTrue
	 *     CmdExpr returns GBoolTrue
	 *     CmdOr returns GBoolTrue
	 *     CmdOr.CmdAnd_1_0_0_0 returns GBoolTrue
	 *     CmdAnd returns GBoolTrue
	 *     CmdAnd.CmdAnd_1_0_0_0 returns GBoolTrue
	 *     CmdEq returns GBoolTrue
	 *     CmdEq.CmdEq_1_0_0_0 returns GBoolTrue
	 *     CmdNeq returns GBoolTrue
	 *     CmdNeq.CmdNEq_1_0_0_0 returns GBoolTrue
	 *     CmdGECompare returns GBoolTrue
	 *     CmdGECompare.CmdGECompare_1_0_0_0 returns GBoolTrue
	 *     CmdLECompare returns GBoolTrue
	 *     CmdLECompare.CmdLECompare_1_0_0_0 returns GBoolTrue
	 *     CmdGCompare returns GBoolTrue
	 *     CmdGCompare.CmdGCompare_1_0_0_0 returns GBoolTrue
	 *     CmdLCompare returns GBoolTrue
	 *     CmdLCompare.CmdLCompare_1_0_0_0 returns GBoolTrue
	 *     CmdAdd returns GBoolTrue
	 *     CmdAdd.CmdAdd_1_0_0_0 returns GBoolTrue
	 *     CmdSub returns GBoolTrue
	 *     CmdSub.CmdSub_1_0_0_0 returns GBoolTrue
	 *     CmdNot returns GBoolTrue
	 *     CmdLit returns GBoolTrue
	 *
	 * Constraint:
	 *     {GBoolTrue}
	 */
	protected void sequence_CmdLit(ISerializationContext context, GBoolTrue semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns IntLitCmd
	 *     Cmd returns IntLitCmd
	 *     CmdExpr returns IntLitCmd
	 *     CmdOr returns IntLitCmd
	 *     CmdOr.CmdAnd_1_0_0_0 returns IntLitCmd
	 *     CmdAnd returns IntLitCmd
	 *     CmdAnd.CmdAnd_1_0_0_0 returns IntLitCmd
	 *     CmdEq returns IntLitCmd
	 *     CmdEq.CmdEq_1_0_0_0 returns IntLitCmd
	 *     CmdNeq returns IntLitCmd
	 *     CmdNeq.CmdNEq_1_0_0_0 returns IntLitCmd
	 *     CmdGECompare returns IntLitCmd
	 *     CmdGECompare.CmdGECompare_1_0_0_0 returns IntLitCmd
	 *     CmdLECompare returns IntLitCmd
	 *     CmdLECompare.CmdLECompare_1_0_0_0 returns IntLitCmd
	 *     CmdGCompare returns IntLitCmd
	 *     CmdGCompare.CmdGCompare_1_0_0_0 returns IntLitCmd
	 *     CmdLCompare returns IntLitCmd
	 *     CmdLCompare.CmdLCompare_1_0_0_0 returns IntLitCmd
	 *     CmdAdd returns IntLitCmd
	 *     CmdAdd.CmdAdd_1_0_0_0 returns IntLitCmd
	 *     CmdSub returns IntLitCmd
	 *     CmdSub.CmdSub_1_0_0_0 returns IntLitCmd
	 *     CmdNot returns IntLitCmd
	 *     CmdLit returns IntLitCmd
	 *
	 * Constraint:
	 *     value=INT
	 */
	protected void sequence_CmdLit(ISerializationContext context, IntLitCmd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.INT_LIT_CMD__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.INT_LIT_CMD__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCmdLitAccess().getValueINTTerminalRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns PortLit
	 *     Cmd returns PortLit
	 *     CmdExpr returns PortLit
	 *     CmdOr returns PortLit
	 *     CmdOr.CmdAnd_1_0_0_0 returns PortLit
	 *     CmdAnd returns PortLit
	 *     CmdAnd.CmdAnd_1_0_0_0 returns PortLit
	 *     CmdEq returns PortLit
	 *     CmdEq.CmdEq_1_0_0_0 returns PortLit
	 *     CmdNeq returns PortLit
	 *     CmdNeq.CmdNEq_1_0_0_0 returns PortLit
	 *     CmdGECompare returns PortLit
	 *     CmdGECompare.CmdGECompare_1_0_0_0 returns PortLit
	 *     CmdLECompare returns PortLit
	 *     CmdLECompare.CmdLECompare_1_0_0_0 returns PortLit
	 *     CmdGCompare returns PortLit
	 *     CmdGCompare.CmdGCompare_1_0_0_0 returns PortLit
	 *     CmdLCompare returns PortLit
	 *     CmdLCompare.CmdLCompare_1_0_0_0 returns PortLit
	 *     CmdAdd returns PortLit
	 *     CmdAdd.CmdAdd_1_0_0_0 returns PortLit
	 *     CmdSub returns PortLit
	 *     CmdSub.CmdSub_1_0_0_0 returns PortLit
	 *     CmdNot returns PortLit
	 *     CmdLit returns PortLit
	 *
	 * Constraint:
	 *     inSide?='inSide'?
	 */
	protected void sequence_CmdLit(ISerializationContext context, PortLit semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns StringLit
	 *     Cmd returns StringLit
	 *     CmdExpr returns StringLit
	 *     CmdOr returns StringLit
	 *     CmdOr.CmdAnd_1_0_0_0 returns StringLit
	 *     CmdAnd returns StringLit
	 *     CmdAnd.CmdAnd_1_0_0_0 returns StringLit
	 *     CmdEq returns StringLit
	 *     CmdEq.CmdEq_1_0_0_0 returns StringLit
	 *     CmdNeq returns StringLit
	 *     CmdNeq.CmdNEq_1_0_0_0 returns StringLit
	 *     CmdGECompare returns StringLit
	 *     CmdGECompare.CmdGECompare_1_0_0_0 returns StringLit
	 *     CmdLECompare returns StringLit
	 *     CmdLECompare.CmdLECompare_1_0_0_0 returns StringLit
	 *     CmdGCompare returns StringLit
	 *     CmdGCompare.CmdGCompare_1_0_0_0 returns StringLit
	 *     CmdLCompare returns StringLit
	 *     CmdLCompare.CmdLCompare_1_0_0_0 returns StringLit
	 *     CmdAdd returns StringLit
	 *     CmdAdd.CmdAdd_1_0_0_0 returns StringLit
	 *     CmdSub returns StringLit
	 *     CmdSub.CmdSub_1_0_0_0 returns StringLit
	 *     CmdNot returns StringLit
	 *     CmdLit returns StringLit
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_CmdLit(ISerializationContext context, StringLit semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.STRING_LIT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.STRING_LIT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCmdLitAccess().getValueSTRINGTerminalRuleCall_3_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns Variable
	 *     Cmd returns Variable
	 *     CmdExpr returns Variable
	 *     CmdOr returns Variable
	 *     CmdOr.CmdAnd_1_0_0_0 returns Variable
	 *     CmdAnd returns Variable
	 *     CmdAnd.CmdAnd_1_0_0_0 returns Variable
	 *     CmdEq returns Variable
	 *     CmdEq.CmdEq_1_0_0_0 returns Variable
	 *     CmdNeq returns Variable
	 *     CmdNeq.CmdNEq_1_0_0_0 returns Variable
	 *     CmdGECompare returns Variable
	 *     CmdGECompare.CmdGECompare_1_0_0_0 returns Variable
	 *     CmdLECompare returns Variable
	 *     CmdLECompare.CmdLECompare_1_0_0_0 returns Variable
	 *     CmdGCompare returns Variable
	 *     CmdGCompare.CmdGCompare_1_0_0_0 returns Variable
	 *     CmdLCompare returns Variable
	 *     CmdLCompare.CmdLCompare_1_0_0_0 returns Variable
	 *     CmdAdd returns Variable
	 *     CmdAdd.CmdAdd_1_0_0_0 returns Variable
	 *     CmdSub returns Variable
	 *     CmdSub.CmdSub_1_0_0_0 returns Variable
	 *     CmdNot returns Variable
	 *     CmdLit returns Variable
	 *
	 * Constraint:
	 *     value=ID
	 */
	protected void sequence_CmdLit(ISerializationContext context, Variable semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.VARIABLE__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.VARIABLE__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCmdLitAccess().getValueIDTerminalRuleCall_4_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns CmdNEq
	 *     Cmd returns CmdNEq
	 *     CmdExpr returns CmdNEq
	 *     CmdOr returns CmdNEq
	 *     CmdOr.CmdAnd_1_0_0_0 returns CmdNEq
	 *     CmdAnd returns CmdNEq
	 *     CmdAnd.CmdAnd_1_0_0_0 returns CmdNEq
	 *     CmdEq returns CmdNEq
	 *     CmdEq.CmdEq_1_0_0_0 returns CmdNEq
	 *     CmdNeq returns CmdNEq
	 *     CmdNeq.CmdNEq_1_0_0_0 returns CmdNEq
	 *     CmdGECompare returns CmdNEq
	 *     CmdGECompare.CmdGECompare_1_0_0_0 returns CmdNEq
	 *     CmdLECompare returns CmdNEq
	 *     CmdLECompare.CmdLECompare_1_0_0_0 returns CmdNEq
	 *     CmdGCompare returns CmdNEq
	 *     CmdGCompare.CmdGCompare_1_0_0_0 returns CmdNEq
	 *     CmdLCompare returns CmdNEq
	 *     CmdLCompare.CmdLCompare_1_0_0_0 returns CmdNEq
	 *     CmdAdd returns CmdNEq
	 *     CmdAdd.CmdAdd_1_0_0_0 returns CmdNEq
	 *     CmdSub returns CmdNEq
	 *     CmdSub.CmdSub_1_0_0_0 returns CmdNEq
	 *     CmdNot returns CmdNEq
	 *     CmdLit returns CmdNEq
	 *
	 * Constraint:
	 *     (left=CmdNeq_CmdNEq_1_0_0_0 right=CmdGECompare)
	 */
	protected void sequence_CmdNeq(ISerializationContext context, CmdNEq semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.CMD_NEQ__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.CMD_NEQ__LEFT));
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.CMD_NEQ__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.CMD_NEQ__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCmdNeqAccess().getCmdNEqLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCmdNeqAccess().getRightCmdGECompareParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns GExpression
	 *     Cmd returns GExpression
	 *     CmdExpr returns GExpression
	 *     CmdOr returns GExpression
	 *     CmdOr.CmdAnd_1_0_0_0 returns GExpression
	 *     CmdAnd returns GExpression
	 *     CmdAnd.CmdAnd_1_0_0_0 returns GExpression
	 *     CmdEq returns GExpression
	 *     CmdEq.CmdEq_1_0_0_0 returns GExpression
	 *     CmdNeq returns GExpression
	 *     CmdNeq.CmdNEq_1_0_0_0 returns GExpression
	 *     CmdGECompare returns GExpression
	 *     CmdGECompare.CmdGECompare_1_0_0_0 returns GExpression
	 *     CmdLECompare returns GExpression
	 *     CmdLECompare.CmdLECompare_1_0_0_0 returns GExpression
	 *     CmdGCompare returns GExpression
	 *     CmdGCompare.CmdGCompare_1_0_0_0 returns GExpression
	 *     CmdLCompare returns GExpression
	 *     CmdLCompare.CmdLCompare_1_0_0_0 returns GExpression
	 *     CmdAdd returns GExpression
	 *     CmdAdd.CmdAdd_1_0_0_0 returns GExpression
	 *     CmdSub returns GExpression
	 *     CmdSub.CmdSub_1_0_0_0 returns GExpression
	 *     CmdNot returns GExpression
	 *     CmdLit returns GExpression
	 *
	 * Constraint:
	 *     expression=CmdLit
	 */
	protected void sequence_CmdNot(ISerializationContext context, GExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.GEXPRESSION__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.GEXPRESSION__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCmdNotAccess().getExpressionCmdLitParserRuleCall_0_1_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns CmdSub
	 *     Cmd returns CmdSub
	 *     CmdExpr returns CmdSub
	 *     CmdOr returns CmdSub
	 *     CmdOr.CmdAnd_1_0_0_0 returns CmdSub
	 *     CmdAnd returns CmdSub
	 *     CmdAnd.CmdAnd_1_0_0_0 returns CmdSub
	 *     CmdEq returns CmdSub
	 *     CmdEq.CmdEq_1_0_0_0 returns CmdSub
	 *     CmdNeq returns CmdSub
	 *     CmdNeq.CmdNEq_1_0_0_0 returns CmdSub
	 *     CmdGECompare returns CmdSub
	 *     CmdGECompare.CmdGECompare_1_0_0_0 returns CmdSub
	 *     CmdLECompare returns CmdSub
	 *     CmdLECompare.CmdLECompare_1_0_0_0 returns CmdSub
	 *     CmdGCompare returns CmdSub
	 *     CmdGCompare.CmdGCompare_1_0_0_0 returns CmdSub
	 *     CmdLCompare returns CmdSub
	 *     CmdLCompare.CmdLCompare_1_0_0_0 returns CmdSub
	 *     CmdAdd returns CmdSub
	 *     CmdAdd.CmdAdd_1_0_0_0 returns CmdSub
	 *     CmdSub returns CmdSub
	 *     CmdSub.CmdSub_1_0_0_0 returns CmdSub
	 *     CmdNot returns CmdSub
	 *     CmdLit returns CmdSub
	 *
	 * Constraint:
	 *     (left=CmdSub_CmdSub_1_0_0_0 right=CmdNot)
	 */
	protected void sequence_CmdSub(ISerializationContext context, CmdSub semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.CMD_SUB__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.CMD_SUB__LEFT));
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.CMD_SUB__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.CMD_SUB__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCmdSubAccess().getCmdSubLeftAction_1_0_0_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getCmdSubAccess().getRightCmdNotParserRuleCall_1_1_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns AcceptCmd
	 *     Cmd returns AcceptCmd
	 *
	 * Constraint:
	 *     {AcceptCmd}
	 */
	protected void sequence_Cmd(ISerializationContext context, AcceptCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns AlarmCmd
	 *     Cmd returns AlarmCmd
	 *
	 * Constraint:
	 *     exp=GExpression
	 */
	protected void sequence_Cmd(ISerializationContext context, AlarmCmd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.ALARM_CMD__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.ALARM_CMD__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCmdAccess().getExpGExpressionParserRuleCall_4_3_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns AutomatonCmd
	 *     Cmd returns AutomatonCmd
	 *
	 * Constraint:
	 *     (name=ID automaton=[AutomataDef|ID])
	 */
	protected void sequence_Cmd(ISerializationContext context, AutomatonCmd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.AUTOMATON_CMD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.AUTOMATON_CMD__NAME));
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.AUTOMATON_CMD__AUTOMATON) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.AUTOMATON_CMD__AUTOMATON));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCmdAccess().getNameIDTerminalRuleCall_6_3_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCmdAccess().getAutomatonAutomataDefIDTerminalRuleCall_6_5_0_1(), semanticObject.eGet(GpflPackage.Literals.AUTOMATON_CMD__AUTOMATON, false));
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns DropCmd
	 *     Cmd returns DropCmd
	 *
	 * Constraint:
	 *     {DropCmd}
	 */
	protected void sequence_Cmd(ISerializationContext context, DropCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns NopCmd
	 *     Cmd returns NopCmd
	 *
	 * Constraint:
	 *     {NopCmd}
	 */
	protected void sequence_Cmd(ISerializationContext context, NopCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns SendCmd
	 *     Cmd returns SendCmd
	 *
	 * Constraint:
	 *     (port=Port fields+=Field*)
	 */
	protected void sequence_Cmd(ISerializationContext context, SendCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns SetCmd
	 *     Cmd returns SetCmd
	 *
	 * Constraint:
	 *     (name=ID exp=CmdExpr)
	 */
	protected void sequence_Cmd(ISerializationContext context, SetCmd semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.SET_CMD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.SET_CMD__NAME));
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.SET_CMD__EXP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.SET_CMD__EXP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCmdAccess().getNameIDTerminalRuleCall_5_3_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getCmdAccess().getExpCmdExprParserRuleCall_5_5_0(), semanticObject.getExp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns StpCmd
	 *     Cmd returns StpCmd
	 *
	 * Constraint:
	 *     (automaton=[AutomatonCmd|ID] event=GExpression errors+=GExpression*)
	 */
	protected void sequence_Cmd(ISerializationContext context, StpCmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Field returns Field
	 *
	 * Constraint:
	 *     (name=ID value=GExpression)
	 */
	protected void sequence_Field(ISerializationContext context, Field semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.FIELD__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.FIELD__NAME));
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.FIELD__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.FIELD__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFieldAccess().getNameIDTerminalRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getFieldAccess().getValueGExpressionParserRuleCall_2_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns CondStmt
	 *
	 * Constraint:
	 *     (exp=GExpression stmts+=GExpression*)
	 */
	protected void sequence_GExpression(ISerializationContext context, CondStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns InterruptStmt
	 *
	 * Constraint:
	 *     (timeout=INT periodic=GExpression stmts+=GExpression*)
	 */
	protected void sequence_GExpression(ISerializationContext context, InterruptStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GExpression returns IterStmt
	 *
	 * Constraint:
	 *     (exp=GExpression stmts+=GExpression*)
	 */
	protected void sequence_GExpression(ISerializationContext context, IterStmt semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Port returns InPort
	 *
	 * Constraint:
	 *     {InPort}
	 */
	protected void sequence_Port(ISerializationContext context, InPort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Port returns OutPort
	 *
	 * Constraint:
	 *     {OutPort}
	 */
	protected void sequence_Port(ISerializationContext context, OutPort semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     (name=ID automatas+=AutomataDef* initStmts+=GExpression* stmts+=GExpression*)
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     State returns State
	 *
	 * Constraint:
	 *     (name=ID transitions+=Transition*)
	 */
	protected void sequence_State(ISerializationContext context, State semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Transition returns Transition
	 *
	 * Constraint:
	 *     (event=ID target=[State|ID])
	 */
	protected void sequence_Transition(ISerializationContext context, Transition semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.TRANSITION__EVENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.TRANSITION__EVENT));
			if (transientValues.isValueTransient(semanticObject, GpflPackage.Literals.TRANSITION__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, GpflPackage.Literals.TRANSITION__TARGET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTransitionAccess().getEventIDTerminalRuleCall_1_0(), semanticObject.getEvent());
		feeder.accept(grammarAccess.getTransitionAccess().getTargetStateIDTerminalRuleCall_3_0_1(), semanticObject.eGet(GpflPackage.Literals.TRANSITION__TARGET, false));
		feeder.finish();
	}
	
	
}
