/*
 * generated by Xtext 2.12.0
 */
package fr.mleduc.macros.language.serializer;

import com.google.inject.Inject;
import fr.mleduc.macros.language.macrosLang.MacrosLangPackage;
import fr.mleduc.macros.language.macrosLang.Model;
import fr.mleduc.macros.language.services.MacrosLangGrammarAccess;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Annotation;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.CharacterRange;
import org.eclipse.xtext.Conjunction;
import org.eclipse.xtext.CrossReference;
import org.eclipse.xtext.Disjunction;
import org.eclipse.xtext.EOF;
import org.eclipse.xtext.EnumLiteralDeclaration;
import org.eclipse.xtext.EnumRule;
import org.eclipse.xtext.GeneratedMetamodel;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.LiteralCondition;
import org.eclipse.xtext.NamedArgument;
import org.eclipse.xtext.NegatedToken;
import org.eclipse.xtext.Negation;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParameterReference;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.ReferencedMetamodel;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.TypeRef;
import org.eclipse.xtext.UnorderedGroup;
import org.eclipse.xtext.UntilToken;
import org.eclipse.xtext.Wildcard;
import org.eclipse.xtext.XtextPackage;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.XtextSemanticSequencer;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class MacrosLangSemanticSequencer extends XtextSemanticSequencer {

	@Inject
	private MacrosLangGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MacrosLangPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MacrosLangPackage.MODEL:
				sequence_Model(context, (Model) semanticObject); 
				return; 
			}
		else if (epackage == XtextPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case XtextPackage.ACTION:
				if (rule == grammarAccess.getAlternativesRule()
						|| action == grammarAccess.getAlternativesAccess().getAlternativesElementsAction_1_0()
						|| rule == grammarAccess.getConditionalBranchRule()
						|| rule == grammarAccess.getUnorderedGroupRule()
						|| action == grammarAccess.getUnorderedGroupAccess().getUnorderedGroupElementsAction_1_0()
						|| rule == grammarAccess.getGroupRule()
						|| action == grammarAccess.getGroupAccess().getGroupElementsAction_1_0()
						|| rule == grammarAccess.getAbstractTokenRule()
						|| rule == grammarAccess.getAbstractTokenWithCardinalityRule()
						|| rule == grammarAccess.getAbstractTerminalRule()
						|| rule == grammarAccess.getParenthesizedElementRule()) {
					sequence_AbstractTokenWithCardinality_Action(context, (Action) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getActionRule()) {
					sequence_Action(context, (Action) semanticObject); 
					return; 
				}
				else break;
			case XtextPackage.ALTERNATIVES:
				if (rule == grammarAccess.getAlternativesRule()
						|| action == grammarAccess.getAlternativesAccess().getAlternativesElementsAction_1_0()
						|| rule == grammarAccess.getConditionalBranchRule()
						|| rule == grammarAccess.getUnorderedGroupRule()
						|| action == grammarAccess.getUnorderedGroupAccess().getUnorderedGroupElementsAction_1_0()
						|| rule == grammarAccess.getGroupRule()
						|| action == grammarAccess.getGroupAccess().getGroupElementsAction_1_0()
						|| rule == grammarAccess.getAbstractTokenRule()
						|| rule == grammarAccess.getAbstractTokenWithCardinalityRule()
						|| rule == grammarAccess.getAbstractTerminalRule()
						|| rule == grammarAccess.getParenthesizedElementRule()) {
					sequence_AbstractTokenWithCardinality_Alternatives(context, (Alternatives) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssignableTerminalRule()
						|| rule == grammarAccess.getParenthesizedAssignableElementRule()
						|| rule == grammarAccess.getAssignableAlternativesRule()
						|| action == grammarAccess.getAssignableAlternativesAccess().getAlternativesElementsAction_1_0()) {
					sequence_AssignableAlternatives(context, (Alternatives) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getEnumLiteralsRule()) {
					sequence_EnumLiterals(context, (Alternatives) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTerminalAlternativesRule()
						|| action == grammarAccess.getTerminalAlternativesAccess().getAlternativesElementsAction_1_0()
						|| rule == grammarAccess.getTerminalGroupRule()
						|| action == grammarAccess.getTerminalGroupAccess().getGroupElementsAction_1_0()
						|| rule == grammarAccess.getTerminalTokenRule()
						|| rule == grammarAccess.getTerminalTokenElementRule()
						|| rule == grammarAccess.getParenthesizedTerminalElementRule()) {
					sequence_TerminalAlternatives_TerminalToken(context, (Alternatives) semanticObject); 
					return; 
				}
				else break;
			case XtextPackage.ANNOTATION:
				sequence_Annotation(context, (Annotation) semanticObject); 
				return; 
			case XtextPackage.ASSIGNMENT:
				if (rule == grammarAccess.getAlternativesRule()
						|| action == grammarAccess.getAlternativesAccess().getAlternativesElementsAction_1_0()
						|| rule == grammarAccess.getConditionalBranchRule()
						|| rule == grammarAccess.getUnorderedGroupRule()
						|| action == grammarAccess.getUnorderedGroupAccess().getUnorderedGroupElementsAction_1_0()
						|| rule == grammarAccess.getGroupRule()
						|| action == grammarAccess.getGroupAccess().getGroupElementsAction_1_0()
						|| rule == grammarAccess.getAbstractTokenRule()
						|| rule == grammarAccess.getAbstractTokenWithCardinalityRule()
						|| rule == grammarAccess.getAbstractTerminalRule()
						|| rule == grammarAccess.getParenthesizedElementRule()) {
					sequence_AbstractTokenWithCardinality_Assignment(context, (Assignment) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAssignmentRule()) {
					sequence_Assignment(context, (Assignment) semanticObject); 
					return; 
				}
				else break;
			case XtextPackage.CHARACTER_RANGE:
				if (rule == grammarAccess.getCharacterRangeRule()) {
					sequence_CharacterRange(context, (CharacterRange) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTerminalAlternativesRule()
						|| action == grammarAccess.getTerminalAlternativesAccess().getAlternativesElementsAction_1_0()
						|| rule == grammarAccess.getTerminalGroupRule()
						|| action == grammarAccess.getTerminalGroupAccess().getGroupElementsAction_1_0()
						|| rule == grammarAccess.getTerminalTokenRule()
						|| rule == grammarAccess.getTerminalTokenElementRule()
						|| rule == grammarAccess.getParenthesizedTerminalElementRule()) {
					sequence_CharacterRange_TerminalToken(context, (CharacterRange) semanticObject); 
					return; 
				}
				else break;
			case XtextPackage.CONJUNCTION:
				sequence_Conjunction(context, (Conjunction) semanticObject); 
				return; 
			case XtextPackage.CROSS_REFERENCE:
				sequence_CrossReference(context, (CrossReference) semanticObject); 
				return; 
			case XtextPackage.DISJUNCTION:
				sequence_Disjunction(context, (Disjunction) semanticObject); 
				return; 
			case XtextPackage.EOF:
				if (rule == grammarAccess.getEOFRule()) {
					sequence_EOF(context, (EOF) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTerminalAlternativesRule()
						|| action == grammarAccess.getTerminalAlternativesAccess().getAlternativesElementsAction_1_0()
						|| rule == grammarAccess.getTerminalGroupRule()
						|| action == grammarAccess.getTerminalGroupAccess().getGroupElementsAction_1_0()
						|| rule == grammarAccess.getTerminalTokenRule()
						|| rule == grammarAccess.getTerminalTokenElementRule()
						|| rule == grammarAccess.getParenthesizedTerminalElementRule()) {
					sequence_EOF_TerminalToken(context, (EOF) semanticObject); 
					return; 
				}
				else break;
			case XtextPackage.ENUM_LITERAL_DECLARATION:
				sequence_EnumLiteralDeclaration(context, (EnumLiteralDeclaration) semanticObject); 
				return; 
			case XtextPackage.ENUM_RULE:
				sequence_EnumRule(context, (EnumRule) semanticObject); 
				return; 
			case XtextPackage.GENERATED_METAMODEL:
				sequence_GeneratedMetamodel(context, (GeneratedMetamodel) semanticObject); 
				return; 
			case XtextPackage.GRAMMAR:
				sequence_Grammar(context, (Grammar) semanticObject); 
				return; 
			case XtextPackage.GROUP:
				if (rule == grammarAccess.getAlternativesRule()
						|| action == grammarAccess.getAlternativesAccess().getAlternativesElementsAction_1_0()
						|| rule == grammarAccess.getConditionalBranchRule()
						|| rule == grammarAccess.getUnorderedGroupRule()
						|| action == grammarAccess.getUnorderedGroupAccess().getUnorderedGroupElementsAction_1_0()
						|| rule == grammarAccess.getGroupRule()
						|| action == grammarAccess.getGroupAccess().getGroupElementsAction_1_0()
						|| rule == grammarAccess.getAbstractTokenRule()
						|| rule == grammarAccess.getAbstractTokenWithCardinalityRule()
						|| rule == grammarAccess.getAbstractTerminalRule()
						|| rule == grammarAccess.getParenthesizedElementRule()) {
					sequence_AbstractTokenWithCardinality_ConditionalBranch_Group_PredicatedGroup(context, (Group) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPredicatedGroupRule()) {
					sequence_PredicatedGroup(context, (Group) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTerminalAlternativesRule()
						|| action == grammarAccess.getTerminalAlternativesAccess().getAlternativesElementsAction_1_0()
						|| rule == grammarAccess.getTerminalGroupRule()
						|| action == grammarAccess.getTerminalGroupAccess().getGroupElementsAction_1_0()
						|| rule == grammarAccess.getTerminalTokenRule()
						|| rule == grammarAccess.getTerminalTokenElementRule()
						|| rule == grammarAccess.getParenthesizedTerminalElementRule()) {
					sequence_TerminalGroup_TerminalToken(context, (Group) semanticObject); 
					return; 
				}
				else break;
			case XtextPackage.KEYWORD:
				if (rule == grammarAccess.getAlternativesRule()
						|| action == grammarAccess.getAlternativesAccess().getAlternativesElementsAction_1_0()
						|| rule == grammarAccess.getConditionalBranchRule()
						|| rule == grammarAccess.getUnorderedGroupRule()
						|| action == grammarAccess.getUnorderedGroupAccess().getUnorderedGroupElementsAction_1_0()
						|| rule == grammarAccess.getGroupRule()
						|| action == grammarAccess.getGroupAccess().getGroupElementsAction_1_0()
						|| rule == grammarAccess.getAbstractTokenRule()
						|| rule == grammarAccess.getAbstractTokenWithCardinalityRule()
						|| rule == grammarAccess.getAbstractTerminalRule()
						|| rule == grammarAccess.getParenthesizedElementRule()) {
					sequence_AbstractTokenWithCardinality_Keyword_PredicatedKeyword(context, (Keyword) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getKeywordRule()
						|| rule == grammarAccess.getAssignableTerminalRule()
						|| rule == grammarAccess.getParenthesizedAssignableElementRule()
						|| rule == grammarAccess.getAssignableAlternativesRule()
						|| action == grammarAccess.getAssignableAlternativesAccess().getAlternativesElementsAction_1_0()
						|| rule == grammarAccess.getCrossReferenceableTerminalRule()
						|| rule == grammarAccess.getCharacterRangeRule()
						|| action == grammarAccess.getCharacterRangeAccess().getCharacterRangeLeftAction_1_0()) {
					sequence_Keyword(context, (Keyword) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTerminalAlternativesRule()
						|| action == grammarAccess.getTerminalAlternativesAccess().getAlternativesElementsAction_1_0()
						|| rule == grammarAccess.getTerminalGroupRule()
						|| action == grammarAccess.getTerminalGroupAccess().getGroupElementsAction_1_0()
						|| rule == grammarAccess.getTerminalTokenRule()
						|| rule == grammarAccess.getTerminalTokenElementRule()
						|| rule == grammarAccess.getParenthesizedTerminalElementRule()) {
					sequence_Keyword_TerminalToken(context, (Keyword) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPredicatedKeywordRule()) {
					sequence_PredicatedKeyword(context, (Keyword) semanticObject); 
					return; 
				}
				else break;
			case XtextPackage.LITERAL_CONDITION:
				sequence_LiteralCondition(context, (LiteralCondition) semanticObject); 
				return; 
			case XtextPackage.NAMED_ARGUMENT:
				sequence_NamedArgument(context, (NamedArgument) semanticObject); 
				return; 
			case XtextPackage.NEGATED_TOKEN:
				if (rule == grammarAccess.getAbstractNegatedTokenRule()
						|| rule == grammarAccess.getNegatedTokenRule()) {
					sequence_NegatedToken(context, (NegatedToken) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTerminalAlternativesRule()
						|| action == grammarAccess.getTerminalAlternativesAccess().getAlternativesElementsAction_1_0()
						|| rule == grammarAccess.getTerminalGroupRule()
						|| action == grammarAccess.getTerminalGroupAccess().getGroupElementsAction_1_0()
						|| rule == grammarAccess.getTerminalTokenRule()
						|| rule == grammarAccess.getTerminalTokenElementRule()
						|| rule == grammarAccess.getParenthesizedTerminalElementRule()) {
					sequence_NegatedToken_TerminalToken(context, (NegatedToken) semanticObject); 
					return; 
				}
				else break;
			case XtextPackage.NEGATION:
				sequence_Negation(context, (Negation) semanticObject); 
				return; 
			case XtextPackage.PARAMETER:
				sequence_Parameter(context, (Parameter) semanticObject); 
				return; 
			case XtextPackage.PARAMETER_REFERENCE:
				sequence_ParameterReference(context, (ParameterReference) semanticObject); 
				return; 
			case XtextPackage.PARSER_RULE:
				sequence_ParserRule_RuleNameAndParams(context, (ParserRule) semanticObject); 
				return; 
			case XtextPackage.REFERENCED_METAMODEL:
				sequence_ReferencedMetamodel(context, (ReferencedMetamodel) semanticObject); 
				return; 
			case XtextPackage.RULE_CALL:
				if (rule == grammarAccess.getAlternativesRule()
						|| action == grammarAccess.getAlternativesAccess().getAlternativesElementsAction_1_0()
						|| rule == grammarAccess.getConditionalBranchRule()
						|| rule == grammarAccess.getUnorderedGroupRule()
						|| action == grammarAccess.getUnorderedGroupAccess().getUnorderedGroupElementsAction_1_0()
						|| rule == grammarAccess.getGroupRule()
						|| action == grammarAccess.getGroupAccess().getGroupElementsAction_1_0()
						|| rule == grammarAccess.getAbstractTokenRule()
						|| rule == grammarAccess.getAbstractTokenWithCardinalityRule()
						|| rule == grammarAccess.getAbstractTerminalRule()
						|| rule == grammarAccess.getParenthesizedElementRule()) {
					sequence_AbstractTokenWithCardinality_PredicatedRuleCall_RuleCall(context, (RuleCall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPredicatedRuleCallRule()) {
					sequence_PredicatedRuleCall(context, (RuleCall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getRuleCallRule()
						|| rule == grammarAccess.getAssignableTerminalRule()
						|| rule == grammarAccess.getParenthesizedAssignableElementRule()
						|| rule == grammarAccess.getAssignableAlternativesRule()
						|| action == grammarAccess.getAssignableAlternativesAccess().getAlternativesElementsAction_1_0()
						|| rule == grammarAccess.getCrossReferenceableTerminalRule()) {
					sequence_RuleCall(context, (RuleCall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTerminalRuleCallRule()) {
					sequence_TerminalRuleCall(context, (RuleCall) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getTerminalAlternativesRule()
						|| action == grammarAccess.getTerminalAlternativesAccess().getAlternativesElementsAction_1_0()
						|| rule == grammarAccess.getTerminalGroupRule()
						|| action == grammarAccess.getTerminalGroupAccess().getGroupElementsAction_1_0()
						|| rule == grammarAccess.getTerminalTokenRule()
						|| rule == grammarAccess.getTerminalTokenElementRule()
						|| rule == grammarAccess.getParenthesizedTerminalElementRule()) {
					sequence_TerminalRuleCall_TerminalToken(context, (RuleCall) semanticObject); 
					return; 
				}
				else break;
			case XtextPackage.TERMINAL_RULE:
				sequence_TerminalRule(context, (TerminalRule) semanticObject); 
				return; 
			case XtextPackage.TYPE_REF:
				sequence_TypeRef(context, (TypeRef) semanticObject); 
				return; 
			case XtextPackage.UNORDERED_GROUP:
				sequence_AbstractTokenWithCardinality_UnorderedGroup(context, (UnorderedGroup) semanticObject); 
				return; 
			case XtextPackage.UNTIL_TOKEN:
				if (rule == grammarAccess.getTerminalAlternativesRule()
						|| action == grammarAccess.getTerminalAlternativesAccess().getAlternativesElementsAction_1_0()
						|| rule == grammarAccess.getTerminalGroupRule()
						|| action == grammarAccess.getTerminalGroupAccess().getGroupElementsAction_1_0()
						|| rule == grammarAccess.getTerminalTokenRule()
						|| rule == grammarAccess.getTerminalTokenElementRule()
						|| rule == grammarAccess.getParenthesizedTerminalElementRule()) {
					sequence_TerminalToken_UntilToken(context, (UntilToken) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getAbstractNegatedTokenRule()
						|| rule == grammarAccess.getUntilTokenRule()) {
					sequence_UntilToken(context, (UntilToken) semanticObject); 
					return; 
				}
				else break;
			case XtextPackage.WILDCARD:
				if (rule == grammarAccess.getTerminalAlternativesRule()
						|| action == grammarAccess.getTerminalAlternativesAccess().getAlternativesElementsAction_1_0()
						|| rule == grammarAccess.getTerminalGroupRule()
						|| action == grammarAccess.getTerminalGroupAccess().getGroupElementsAction_1_0()
						|| rule == grammarAccess.getTerminalTokenRule()
						|| rule == grammarAccess.getTerminalTokenElementRule()
						|| rule == grammarAccess.getParenthesizedTerminalElementRule()) {
					sequence_TerminalToken_Wildcard(context, (Wildcard) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getWildcardRule()) {
					sequence_Wildcard(context, (Wildcard) semanticObject); 
					return; 
				}
				else break;
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Model returns Model
	 *
	 * Constraint:
	 *     (name=ID path=[Grammar|GrammarID])
	 */
	protected void sequence_Model(ISerializationContext context, Model semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MacrosLangPackage.Literals.MODEL__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MacrosLangPackage.Literals.MODEL__NAME));
			if (transientValues.isValueTransient(semanticObject, MacrosLangPackage.Literals.MODEL__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MacrosLangPackage.Literals.MODEL__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getModelAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getModelAccess().getPathGrammarGrammarIDParserRuleCall_3_0_1(), semanticObject.eGet(MacrosLangPackage.Literals.MODEL__PATH, false));
		feeder.finish();
	}
	
	
}
